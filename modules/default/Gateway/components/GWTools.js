function readConfig(e) { return new Promise((r => { var o = void 0; let n = e.lib.path.resolve(__dirname, "../../../../config/config.js");
        e.lib.fs.existsSync(n) && (o = configStartMerge(o = require(n))), r(o) })) }

function readTMPBackupConfig(e, r) { return new Promise((o => { var n = void 0;
        e.lib.fs.existsSync(r) && (n = configStartMerge(n = require(r)), e.lib.fs.unlink(r, (e => { if (e) return console.error("[GATEWAY] error", e) })), o(n)) })) }

function readFreeteuseTV(e) { return new Promise((r => { var o = void 0; let n = e.lib.path.resolve(__dirname, "../../EXT-FreeboxTV/streamsConfig.json");
        e.lib.fs.existsSync(n) && (o = require(n)), r(o) })) }

function readRadioRecipe(e) { return new Promise((r => { var o = void 0,
            n = e.Gateway.language; let t = e.lib.path.resolve(__dirname, "../../EXT-RadioPlayer/recipe/EXT-RadioPlayer." + n + ".js"); try { e.lib.fs.existsSync(t) && (o = require(t).recipe.commands) } catch (e) { r(o), console.error("[GATEWAY] [Radio] error when loading file", t) }
        r(o) })) }

function searchConfigured(e, r) { try { var o = []; return e.modules.find((e => { r.includes(e.module) && o.push(e.module) })), o.sort() } catch (e) { return console.log("[GATEWAY] Error! " + e), o.sort() } }

function searchInstalled(e) { var r = []; return e.Gateway.EXT.find((o => { if (e.lib.fs.existsSync(e.lib.path.resolve(__dirname + "/../../" + o + "/package.json"))) { let n = require(e.lib.path.resolve(__dirname + "/../../" + o + "/package.json")).name;
            n == o ? r.push(o) : console.warn("[GATEWAY] Found:", o, "but in package.json name is not the same:", n) } })), r.sort() }

function searchGA(e) { var r = 0; if (e.lib.fs.existsSync(e.lib.path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json"))) { let o = require(e.lib.path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json")).name; "MMM-GoogleAssistant" == o ? r = require(e.lib.path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json")).version : console.warn("[GATEWAY] Found: MMM-GoogleAssistant but in package.json name is not the same:", o) } return r }

function timeStamp() { for (var e = new Date, r = [e.getFullYear(), e.getMonth() + 1, e.getDate()], o = [e.getHours(), e.getMinutes(), e.getSeconds()], n = 0; n < 3; n++) o[n] < 10 && (o[n] = "0" + o[n]), r[n] < 10 && (r[n] = "0" + r[n]); return r.join("") + "-" + o.join(":") }

function saveConfig(e, r) { return new Promise((o => { var n = e.lib.path.resolve(__dirname, "../../../../config/config.js"),
            t = e.lib.path.resolve(__dirname, "../../../config/configTMP.js"); let i = e.lib.path.resolve(__dirname, "../backup/config.js.GW." + timeStamp()); var a = e.lib.fs.createReadStream(n),
            s = e.lib.fs.createWriteStream(i);
        a.pipe(s, { end: !1 }), a.on("end", (() => { var a = "/*** GENERATED BY @bugsounet Gateway v" + require("../package.json").version + " ***/\n/*** https://forum.bugsounet.fr **/\n\nvar config = ";
            e.lib.fs.writeFile(t, a + e.lib.util.inspect(r, { showHidden: !1, depth: null, maxArrayLength: null, compact: !1 }) + "\n\n/*************** DO NOT EDIT THE LINE BELOW ***************/\nif (typeof module !== 'undefined') {module.exports = config;}\n", (r => { if (r) return o({ error: "Error when writing file" }), console.error("[GATEWAY] error", r);
                console.log("[GATEWAY] Gateway saved TMP configuration!"), console.log("[GATEWAY] Backup saved in", i), console.log("[GATEWAY] Gateway check Function in config and revive it..."); var a = new RegExp(/(.*)(`|')\[FUNCTION\](.*)(`|')/, "g");! function(r, n) { e.lib.fs.unlink(n, (e => { if (e) return o({ error: "Error when deleting file" }), console.error("[GATEWAY] error", e) })); var t = e.lib.fs.createReadStream(r),
                        i = new e.lib.Stream;
                    i.readable = !0, i.writable = !0, e.lib.readline.createInterface({ input: t, output: i, terminal: !1 }).on("line", (r => { var o = a.exec(r); if (o) return r = reviver(o), e.lib.fs.appendFileSync(n, r + "\n");
                        e.lib.fs.appendFileSync(n, r + "\n") })), t.on("end", (() => { e.lib.fs.unlink(r, (e => { if (e) return o({ error: "Error when deleting file" }), console.error("[GATEWAY] error", e);
                            o({ done: "ok" }) })) })) }(t, n) })) })), s.on("error", (e => { o({ error: "Error when writing file" }), console.log("[GATEWAY]", e) })) })) }

function saveExternalConfig(e, r) { return new Promise((o => { var n = Date.now(),
            t = e.lib.path.resolve(__dirname, "../tmp/configTMP.js"),
            i = e.lib.path.resolve(__dirname, "../download/" + n + ".js"),
            a = "/*** GENERATED BY @bugsounet Gateway v" + require("../package.json").version + " ***/\n/*** https://forum.bugsounet.fr **/\n\nvar config = ";
        e.lib.fs.writeFile(t, a + e.lib.util.inspect(r, { showHidden: !1, depth: null, maxArrayLength: null, compact: !1 }) + "\n\n/*************** DO NOT EDIT THE LINE BELOW ***************/\nif (typeof module !== 'undefined') {module.exports = config;}\n", (r => { if (r) return o({ error: "Error when writing file" }), console.error("[GATEWAY] error", r); var a, s, l, c, u = new RegExp(/(.*)(`|')\[FUNCTION\](.*)(`|')/, "g");
            a = t, s = i, l = e.lib.fs.createReadStream(a), (c = new e.lib.Stream).readable = !0, c.writable = !0, e.lib.readline.createInterface({ input: l, output: c, terminal: !1 }).on("line", (r => { var o = u.exec(r); if (o) return r = reviver(o), e.lib.fs.appendFileSync(s, r + "\n");
                e.lib.fs.appendFileSync(s, r + "\n") })), l.on("end", (() => { console.log("[GATEWAY] Gateway saved new backup configuration for downloading !"), e.lib.fs.unlink(a, (e => { if (e) return o({ error: "Error when deleting file" }), console.error("[GATEWAY] error", e);
                    o({ data: n }) })) })) })) })) }

function deleteDownload(e, r) { var o = e.lib.path.resolve(__dirname, "../download/" + r + ".js");
    e.lib.fs.unlink(o, (e => { if (e) return console.error("[GATEWAY] error", e);
        console.log("[GATEWAY] Successfully deleted:", o) })) }

function transformExternalBackup(e, r) { return new Promise((o => { var n = e.lib.path.resolve(__dirname, "../tmp/config.tmp" + timeStamp());
        e.lib.fs.writeFile(n, r, (async r => { r ? (console.log("[GATEWAY][externalBackup]", r), o({ error: "Error when writing external tmp backup file" })) : (result = await readTMPBackupConfig(e, n), o(result)) })) })) }

function configAddOrModify(e, r) { return new Promise((o => { modules = r.modules, index = modules.map((e => e.module)).indexOf(e.module), index > -1 ? modules[index] = e : modules.push(e), o(r) })) }

function configDelete(e, r) { return new Promise((o => { modules = r.modules, index = modules.map((e => e.module)).indexOf(e), modules.splice(index, 1), o(r) })) }

function loadBackupNames(e) { return new Promise((r => { var o = [];
        e.lib.fs.readdirSync(e.lib.path.resolve(__dirname, "../backup/")).forEach((e => { e.match("config.js.GW") && o.push(e) })), o.sort(), o.reverse(), r(o) })) }

function deleteBackup(e) { return new Promise((r => { e.lib.fs.readdirSync(e.lib.path.resolve(__dirname, "../backup/")).forEach((r => { if (r.match("config.js.GW")) { pathFile = e.lib.path.resolve(__dirname, "../backup/" + r); try { e.lib.fs.unlinkSync(pathFile) } catch (e) { console.error("[GATEWAY] Error occurred while trying to remove this file:", r) } } })), r({ done: "ok" }) })) }

function loadBackupFile(e, r) { return new Promise((o => { var n = {}; let t = e.lib.path.resolve(__dirname, "../backup/" + r);
        e.lib.fs.existsSync(t) && (n = configStartMerge(n = require(t))), o(n) })) }

function getIP(e) { return new Promise((r => { e.lib.si.networkInterfaceDefault().then((o => { e.lib.si.networkInterfaces().then((e => { var n = [],
                    t = 0;
                e.forEach((i => { var a = {}; "wireless" == i.type && (a = { ip: i.ip4 ? i.ip4 : "unknow", default: i.iface == o }), "wired" == i.type && (a = { ip: i.ip4 ? i.ip4 : "unknow", default: i.iface == o }), "lo" != i.iface && n.push(a), t == e.length - 1 ? r(n) : t += 1 })) })) })).catch((e => { var o;
            console.log(e), o = { ip: "127.0.0.1", default: !0 }, Interfaces.push(o), r(Interfaces) })) })) }
async function purposeIP(e) { var r = await getIP(e),
        o = 0; return new Promise((e => { r.forEach((r => { if (r.default) return e(r.ip), void(o = 1) })), o || e("127.0.0.1") })) }

function configStartMerge(e) { for (var r, o, n = Array.prototype.slice.call(arguments, 0); n.length;)
        for (o in r = n.shift())
            if (r.hasOwnProperty(o))
                if ("object" == typeof e[o] && e[o] && "[object Array]" !== Object.prototype.toString.call(e[o])) "object" == typeof r[o] && null !== r[o] ? e[o] = configStartMerge({}, e[o], r[o]) : e[o] = r[o];
                else if ("[object Array]" == Object.prototype.toString.call(e[o])) e[o] = configStartMerge([], e[o], r[o]);
    else if ("[object Object]" == Object.prototype.toString.call(e[o])) e[o] = configStartMerge({}, e[o], r[o]);
    else if ("[object Function]" == Object.prototype.toString.call(e[o])) { let n = JSON.stringify(r[o], replacer, 2);
        n = n.slice(0, -1), n = n.slice(1), e[o] = n } else e[o] = r[o]; return e }

function configMerge(e) { for (var r, o, n = Array.prototype.slice.call(arguments, 1); n.length;)
        for (o in r = n.shift()) r.hasOwnProperty(o) && ("object" == typeof e[o] && e[o] && "[object Array]" !== Object.prototype.toString.call(e[o]) && "object" == typeof r[o] && null !== r[o] ? e[o] = configMerge({}, e[o], r[o]) : e[o] = r[o]); return e }

function checkElectronOptions(e) { return !("object" != typeof e.electronOptions || "object" != typeof e.electronOptions.webPreferences || !e.electronOptions.webPreferences.webviewTag) }

function setWebviewTag(e) { return new Promise((r => { r(e = configMerge({}, e, { electronOptions: { webPreferences: { webviewTag: !0 } } })) })) }

function restartMM(e) { e.config.usePM2 ? (console.log("[GATEWAY] PM2 will restarting MagicMirror..."), e.lib.pm2.restart(e.config.PM2Id, ((e, r) => { e && console.log("[GATEWAY] " + e) }))) : doRestart(e) }

function doRestart(e) { console.log("[GATEWAY] Restarting MagicMirror..."); var r = e.lib.path.normalize(__dirname + "/../../../"); const o = process.stdout,
        n = process.stderr;
    e.lib.childProcess.spawn("npm start", { cwd: r, shell: !0, detached: !0, stdio: ["ignore", o, n] }).unref(), process.exit() }

function doClose(e) { console.log("[GATEWAY] Closing MagicMirror..."), e.config.usePM2 ? e.lib.pm2.stop(e.config.PM2Id, ((e, r) => { e && console.log("[GATEWAY] " + e) })) : process.exit() }

function SystemRestart(e) { console.log("[GATEWAY] Restarting OS..."), e.lib.childProcess.exec("sudo reboot now", ((e, r, o) => { e && console.error("[GATEWAY] Error when restarting OS!", e) })) }

function SystemDie(e) { console.log("[GATEWAY] Shutdown OS..."), e.lib.childProcess.exec("sudo shutdown now", ((e, r, o) => { e && console.error("[GATEWAY] Error when Shutdown OS!", e) })) }

function getGAConfig(e) { var r = e.modules.map((e => e.module)).indexOf("MMM-GoogleAssistant"); return r > -1 ? e.modules[r] : {} }

function makeSchemaTranslate(e, r) {
    function o(e) { return e.replace(new RegExp("{([^}]+)}", "g"), (function(o, n) { return n in r == 0 && console.warn("[GATEWAY][Translator] Missing:", e), n in r ? r[n] : "{" + n + "}" })) } return function e(r) { for (var n, t, i = Array.prototype.slice.call(arguments, 0); i.length;)
            for (t in n = i.shift()) n.hasOwnProperty(t) && ("object" == typeof r[t] && r[t] && "[object Array]" !== Object.prototype.toString.call(r[t]) ? "object" == typeof n[t] && null !== n[t] ? r[t] = e({}, r[t], n[t]) : r[t] = n[t] : "title" != t && "description" != t || !r[t] ? r[t] = n[t] : r[t] = o(n[t])); return r }(e) }

function readAllMMLogs(e) { return new Promise((r => { var o = "";
        e.forEach((e => { o += e.replace(/\r?\n/g, "\r\n") })), r(o) })) }
async function setActiveVersion(e, r) { if (null != r.Gateway.activeVersion[e]) return r.sendSocketNotification("ERROR", "Already Activated: " + e + ".You can't use Gateway in server mode!"), void console.error("Already Activated: " + e + ". You can't use Gateway in server mode!");
    console.log("[GATEWAY] Detected:", e), r.Gateway.activeVersion[e] = { version: "Gateway" == e ? require("../package.json").version : require("../../" + e + "/package.json").version, rev: "Gateway" == e ? require("../package.json").rev : require("../../" + e + "/package.json").rev }; let o = await checkUpdate(e, r.Gateway.activeVersion[e].version, r);
    r.Gateway.activeVersion[e].last = o.last, r.Gateway.activeVersion[e].update = o.update, r.Gateway.activeVersion[e].beta = o.beta, setInterval((() => { checkUpdateInterval(e, r.Gateway.activeVersion[e].version, r) }), 6e4) }
async function checkUpdateInterval(e, r, o) { let n = await checkUpdate(e, r, o);
    o.Gateway.activeVersion[e].last = n.last, o.Gateway.activeVersion[e].update = n.update, o.Gateway.activeVersion[e].beta = n.beta }

function checkUpdate(e, r, o, n = "master", t = 0) { let i = "https://raw.githubusercontent.com/bugsounet/" + e + "/" + n + "/package.json",
        a = { last: r, update: !1, beta: !1 }; return new Promise((s => { o.lib.fetch(i).then((e => e.json())).then((e => { a.last = e.version, o.lib.semver.gt(a.last, r) ? a.update = !0 : o.lib.semver.gt(r, a.last) && (a.beta = !0), s(a) })).catch((async i => { t ? console.error("[GATEWAY] Error on fetch last version of", e, i.message) : a = await checkUpdate(e, r, o, n = "main", t = 1), s(a) })) })) }

function replacer(e, r) { return "function" == typeof r ? "[FUNCTION]" + r.toString() : r }

function reviver(e) { var r = e[3].replace(/\\n/g, "\n"); return r = r.replace(/\\/g, ""), e[1] + r }

function getHomeText(e, r) { return new Promise((async o => { var n = null; let t = e.path.resolve(__dirname, "../translations/" + r + ".home"),
            i = e.path.resolve(__dirname, "../translations/default.home");
        e.fs.existsSync(t) ? (console.log("[GATEWAY] [TRANSLATION] [HOME] Use:", r + ".home"), n = await readThisFile(e, t)) : (console.log("[GATEWAY] [TRANSLATION] [HOME] Use: default.home"), n = await readThisFile(e, i)), o(n) })) }

function readThisFile(e, r) { return new Promise((o => { e.fs.readFile(r, ((e, r) => { e && (console.log("[GATEWAY] [TRANSLATION] [HOME] Error", e), o()), o(r.toString()) })) })) }

function MMConfigAddress(e) { return new Promise((r => { "0.0.0.0" == e.Gateway.MMConfig.address ? (e.Gateway.errorInit = !0, console.error("[GATEWAY] Error: You can't use '0.0.0.0' in MagicMirror address config"), e.sendSocketNotification("ERROR", "You can't use '0.0.0.0' in MagicMirror address config"), r(!0)) : (console.log("[GATEWAY] MagicMirror address:", e.Gateway.MMConfig.address), r(!1)) })) }
exports.purposeIP = purposeIP, exports.readConfig = readConfig, exports.saveConfig = saveConfig, exports.configAddOrModify = configAddOrModify, exports.configDelete = configDelete, exports.searchConfigured = searchConfigured, exports.searchInstalled = searchInstalled, exports.loadBackupNames = loadBackupNames, exports.loadBackupFile = loadBackupFile, exports.configMerge = configMerge, exports.checkElectronOptions = checkElectronOptions, exports.doClose = doClose, exports.restartMM = restartMM, exports.searchGA = searchGA, exports.getGAConfig = getGAConfig, exports.setWebviewTag = setWebviewTag, exports.deleteBackup = deleteBackup, exports.makeSchemaTranslate = makeSchemaTranslate, exports.readAllMMLogs = readAllMMLogs, exports.readFreeteuseTV = readFreeteuseTV, exports.readRadioRecipe = readRadioRecipe, exports.transformExternalBackup = transformExternalBackup, exports.saveExternalConfig = saveExternalConfig, exports.deleteDownload = deleteDownload, exports.SystemRestart = SystemRestart, exports.SystemDie = SystemDie, exports.setActiveVersion = setActiveVersion, exports.getHomeText = getHomeText, exports.MMConfigAddress = MMConfigAddress;